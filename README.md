## Содержание

* [Введение](#введение)
* [Отказ от ответственности](#отказ-от-ответственности)
* [Задачи](#задачи)

## Введение

Решение всех задач с ejudge осени 2022 года. Программы написаны на Python и C++. С исходным кодом прилагаются тесты
(некоторые совпадают с теми, что на самой платформе), а также скрипт для их запуска.

## Отказ от ответственности

Решения не являются эталонными, тесты не обеспечивают 100% покрытие. Если реализуя свой алгоритм по подобию моего, вы
не пройдете тесты или получите дисквалификацию - это будет вашей проблемой.
В любом случае все задачи рекомендуется решать своими силами и знаниями - так честнее и даст больше пользы.

## Задачи

### Модуль 1

### [Сумма (А)](Module1/A/one_A_sum.py)

На стандартном потоке ввода задаётся последовательность целых чисел.
Каждое число последовательности не меньше -200 000 000 и не больше 200 000 000.
На стандартный поток вывода напечатайте сумму этих чисел.

**Проблемы**
</br>Формат входных данных не определен - разделителем чисел может быть что угодно.

### [Дэк (B)](Module1/B/one_B_dequeue.py)

Реализуйте дек (двустороннюю очередь), используя только массив.

**Формат входных данных**
</br>На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.
Первая строка всегда содержит "`set_size N`", где N - максимальный размер дека, целое число.
Каждая последующая строка содержит ровно одну команду: `pushf X`, `pushb X`, `popf`, `popb` или `print`, где
X - произвольная строка без пробелов.

**Формат результата**
</br>Команда `print` выводит содержимое дека одной строкой, значения разделяются пробелами. Если дек пуст, то
выводится "`empty`".
Команда `pushb` добавляет элемент в конец дека, а `pushf` — в начало.
В случае переполнения дека выводится "overflow".
Команда `popf` извлекает и выводит первый элемент или "`underflow`", если дек пуст. Команда `popb` делает то же самое
для последнего элемента.
Память под дек должна быть выделена не более одного раза, при вызове команды "`set_size`".
В любой непонятной ситуации результатом работы любой команды будет "`error`".
Результат работы программы выводится в стандартный поток вывода.

**Проблемы**
</br>Вход может быть некорректным - требуется хороший парсер.

### [Зависимости библиотек (C)](Module1/C/one_C_dependencies.py)

Реализуйте вывод всех путей до уязвимых библиотек для проекта.

**Формат входных данных**
</br> Данные передаются через стандартный поток ввода.
Первая строка содержит идентификаторы уязвимых библиотек, разделенные пробелом.
Вторая строка содержит идентификаторы прямых зависимостей проекта, разделенные пробелом.
Каждая последующая строка содержит идентификатор зависимости и идентификаторы библиотек, от которых она зависит,
разделенные пробелом.

**Формат результата**
</br> Результат работы программы выводится в стандартный поток вывода.
Каждая строка должна содержать путь (набор идентификаторов, разделенный пробелом) к уязвимой зависимости.
Начало пути — прямая зависимость проекта, конец — уязвимая библиотека.
Порядок строк не имеет значения.

**Проблемы**
</br>В тестах примеры, требующие очень много времени, поэтому нужна хорошая оптимизация.

### Модуль 2

### [Косое дерево (B)](Module2/B/2B_splay.cpp)

Реализуйте косое дерево (splay tree).
Реализация самой структуры данных должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и
непосредственно ввода/вывода.
Тесты предполагают "левостороннюю" реализацию, т.е. если действие можно реализовать двумя симметричными способами, надо
делать тот, который больше использует левую сторону.

**Формат входных данных**
</br> На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.
Каждая строка содержит ровно одну команду: `add K V`, `set K V`, `delete K`, `search K`, `min`, `max` или `print`, где
K - целое число (64 бита вам хватит), ключ, V - произвольная строка без пробелов (значение).

**Формат результата**
</br> Команда add добавляет значение V в дерево по ключу K, `set` - изменяет данные по ключу, команда `delete` удаляет
данные.
Команда `search` выводит либо "1 V", либо "0", где V - значение для найденного ключа.
Команды `min` и max выводят "K V", где K - минимальный или максимальный ключ дерева соответственно, V - значение по
этому ключу.
Команда `print` выводит все дерево целиком. Она не изменяет дерево.
Дерево выводится строго по уровням, слева направо, 1 строка - 1 уровень. Первая строка содержит только корень дерева в
формате "`[K V]`" или "`_`", если дерево пустое.
Каждая последующая строка содержит один уровень дерева. Вершины выводятся в формате "`[K V P]`", где P - ключ
родительской вершины. Если вершина отсутствует, ставится "`_`". Вершины разделены пробелом.
В любой непонятной ситуации результатом работы любой команды будет "`error`".
Результат работы программы выводится в стандартный поток вывода.

**Проблемы**
</br>Кривые данные на входе, требующие парсер, большие данные, требующие много времени. Необходима грамотная
инкапсуляция.

### [Min-куча (C)](Module2/C/2C_minheap.cpp)

Реализуйте двоичную min-кучу. Модифицируйте ее таким образом, чтобы внутреннее ее строение было таким же, но при этом
доступ по ключу к любому элементу осуществлялся в среднем за константное время.
Реализация самой структуры данных должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и
непосредственно ввода/вывода.

**Формат входных данных**
</br> На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.
Каждая строка содержит ровно одну команду: `add K V`, `set K V`, `delete K`, `search K`, `min`, `max`, `extract`
или `print`, где K - целое число (64 бита вам хватит), ключ, V - произвольная строка без пробелов (значение).

**Формат результата**
</br> Команда add добавляет значение V в кучу по ключу K, `set` - изменяет данные по ключу, команда delete удаляет
данные.
Команда `search` выводит либо "`1 I V`", либо "`0`", где I - индекс, V - значение для найденного ключа
Команды `min` и `max` выводят "`K I V`", где K - минимальный или максимальный ключ кучи соответственно, I - индекс, V -
значение по этому ключу.
Команда `extract` извлекает корень кучи и выводит "`K V`", где K, V - ключ и значение извлеченного элемента.
Команда `print` выводит всю кучу целиком.
Куча выводится строго по уровням, слева направо, 1 строка - 1 уровень. Первая строка содержит только корень кучи в
формате "`[K V]`" или "`_`", если куча пустая.
Каждая последующая строка содержит один уровень кучи. Вершины выводятся в формате "`[K V P]`", где P - ключ родительской
вершины. Если вершина отсутствует, ставится "`_`". Вершины разделены пробелом.
В любой непонятной ситуации результатом работы любой команды будет "`error`".
Результат работы программы выводится в стандартный поток вывода.

**Проблемы**
</br>Кривые данные на входе, требующие парсер, большие данные, требующие много времени. Необходима грамотная
инкапсуляция.

### [Автокоррекция на префиксном дереве (D)](Module2/D/two_D_prefix.py)

Реализуйте программу, которая предлагает варианты замены слова, в котором допущена одна ошибка.
Для решения этой задачи реализуйте сжатое префиксное дерево.
Регистр букв для программы коррекции не имеет значения (слова в словаре хранятся в нижнем регистре).
Варианты ошибок - как в алгоритме Дамерау-Левенштейна: вставка лишнего символа, удаление символа, замена символа или
транспозиция соседних символов.
Реализация алгоритма должна быть инкапсулирована. В комментариях напишите сложность ключевых алгоритмов с пояснением.
Обход детей узла можно и нужно реализовать в среднем за время, линейно зависящее от длины подходящего префикса.
Соответственно, проверка наличия слова в префиксном дереве — это в среднем линейная операция, зависящая только от длины
слова.

**Формат входных данных**
</br> Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит число N - количество слов в словаре.
Последующие N строк содержат слова из словаря, по одному в строке.
Остальные строки - слова, которые надо проверять.

**Формат результата**
</br> Каждая строка выхода содержит предложение для исправления слова. Слова обрабатываются в порядке их появления.
Если слово не содержит ошибок, то выводится "`%слово% - ok`".
Если слово содержит одну ошибку, то выводится "`%слово% -> %слово_в_словаре%`". Если вариантов несколько, то они
сортируются лексикографически и разделяются запятой с пробелом.
Если слово содержит более одной ошибки, то выводится "`%слово% -?`"
Результат работы программы выводится в стандартный поток вывода.

**Проблемы**
</br> Неожиданные данные на входе, требуется разумная сложность.

### Модуль 3

### [Время блокировки (А)](Module3/A/three_A_block.py)

Реализуйте алгоритм, который на основе истории неуспешных попыток логина пользователя в систему блокирует ему доступ.
Пользователь блокируется на некоторый период времени B в случае нескольких неуспешных попыток входа N в течение
определенного интервала времени P.
Блокировка начинается сразу после последней неудачной попытки логина.
В случае, если пользователь уже был недавно заблокирован, то время повторной блокировки удваивается за каждую
блокировку, т.е. растет экспоненциально. При этом время блокировки ограничено сверху некоторым периодом B_max.
При расчете учитываются все попытки за период 2*B_max.
В примере ниже если пользователь совершит 5 неуспешных попыток в течение часа, то он должен быть заблокирован на 2 часа.
Если после окончания блока он еще раз не сможет залогиниться за 5 попыток в течение часа, то он будет заблокирован уже
на 4 часа, потом на 8 и т.д., но не более чем на 30 дней.
В комментариях к программе напишите асимптотическую сложность алгоритма и использование памяти с пояснениями, как вы их
рассчитали.

**Формат входных данных**
</br> В первой строке стандартного потока записаны через пробел параметры задачи: количество попыток N, интервал P в
секундах, начальное время блокировки B в секундах, максимальное время блокировки B_max в секундах и текущее Unix-время.
Каждая последующая строка содержит Unix-время неудачной попытки логина пользователя
Все параметры и времена — целые неотрицательные числа.

**Формат результата**
</br> Вывод должен содержать Unix-время окончания блокировки пользователя или ok, если пользователя не надо блокировать
или время его блокировки истекло.
Результат работы программы выводится в стандартный поток вывода.

### [Фильтр Блума (B)](Module3/B/three_B_bloom.py)

Реализуйте фильтр Блума, позволяющий дать быстрый, но вероятностный ответ, присутствует ли объект в коллекции.
Реализация самой структуры данных должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и
непосредственно ввода/вывода.
Реализация битового массива также должна быть инкапсулирована. Массив битов должен быть эффективно расположен в памяти.
Параметрами структуры данных являются n - приблизительное количество элементов (целое), P - вероятность
ложноположительного ответа.
Размер структуры, m, вычисляется как `-n*log_{2}P/ln2`, а количество хэш-функций - как `-log_{2}P`. Оба значения
округляются до ближайшего целого.
В качестве семейства функций используйте семейство хэш-функций вида
`h_{i}(x) = (((i + 1)*x + p_{i+1}) mod M) mod m`, где - x - ключ, i - номер хэш-функции, `i∈[0; k-1]`, `p_{j}` - j-тое
по счету простое число, а M - 31ое число Мерсенна.

**Формат входных данных**
</br> На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.
Первая строка содержит команду вида `set n P`.
Каждая последующая строка содержит ровно одну команду: `add K`, `search K` или `print`, где K - неотрицательное число
(64 бита вам хватит), ключ.

**Формат результата**
</br> Команда `set` инициализирует структуру и выводит вычисленные параметры в формате "`m k`".
Команда `add` добавляет в структуру ключ K.
Команда `search` выводит либо "`1`", если элемент возможно присутствует в структуре, либо "0", если он там отсутствует.
Команда `print` выводит внутреннее состояние структуры - последовательность из 0 и 1, не разделенную пробелами.
В любой непонятной ситуации результатом работы любой команды будет "`error`".
Результат работы программы выводится в стандартный поток вывода.

**Проблемы**
</br> Кривые данные на входе.

### [Приближенный рюкзак (C)](Module3/C/3C_knapsack.cpp)

Решите задачу о рюкзаке приближенно. Алгоритм должен быть инкапсулирован.

**Формат входных данных**
</br> Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит дробное число от 0 до 1 — коэффициент приближения. 0 — решение должно совпасть с оптимальным,
0.1 — отличается не более чем на 10% и т.д.
Вторая строка содержит целое неотрицательное число — максимальную массу предметов, которую выдержит рюкзак.
Каждая последующая содержит два целых неотрицательных числа: массу предмета и его стоимость.

**Формат результата**
</br> Первая строка содержит два числа: суммарную массу предметов и их суммарную стоимость.
В последующих строках записаны номера предметов, которые были помещены в рюкзак. Порядок не важен.
Результат работы программы выводится в стандартный поток вывода.
