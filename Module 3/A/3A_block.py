"""
Блокировка логина
Реализуйте алгоритм, который на основе истории неуспешных попыток логина пользователя в систему блокирует ему доступ.
Пользователь блокируется на некоторый период времени B в случае нескольких неуспешных попыток входа N в течение
определенного интервала времени P.
Блокировка начинается сразу после последней неудачной попытки логина.
В случае, если пользователь уже был недавно заблокирован, то время повторной блокировки удваивается за каждую
блокировку, т.е. растет экспоненциально. При этом время блокировки ограничено сверху некоторым периодом B_max.
При расчете учитываются все попытки за период 2*B_max.
В примере ниже если пользователь совершит 5 неуспешных попыток в течение часа, то он должен быть заблокирован на 2 часа.
Если после окончания блока он еще раз не сможет залогиниться за 5 попыток в течение часа, то он будет заблокирован уже
на 4 часа, потом на 8 и т.д., но не более чем на 30 дней.
В комментариях к программе напишите асимптотическую сложность алгоритма и использование памяти с пояснениями, как вы их
рассчитали.

Формат входных данных
В первой строке стандартного потока записаны через пробел параметры задачи: количество попыток N, интервал P в секундах,
начальное время блокировки B в секундах, максимальное время блокировки B_max в секундах и текущее Unix-время.
Каждая последующая строка содержит Unix-время неудачной попытки логина пользователя
Все параметры и времена — целые неотрицательные числа.

Формат результата
Вывод должен содержать Unix-время окончания блокировки пользователя или ok, если пользователя не надо блокировать или
время его блокировки истекло.
Результат работы программы выводится в стандартный поток вывода.
"""

import sys


def calc_unban_time(attempts_number, interval, start_time, max_block, cur_time, attempts):
    """
    n - число попыток, введенных с клавиатуры
    Временная сложность O(n*log(n))        из-за сортировки записей
    Расход памяти O(n)                     расходуется на хранение записей
    """
    tbu = 0  # time before unban
    last_interval = max_block
    counter = 0

    attempts.sort()
    i_first = 0
    for i in range(len(attempts)):
        if cur_time - attempts[i] > 2 * last_interval:
            continue

        if not counter:
            i_first = i
        if attempts[i] <= attempts[i_first] + interval:
            counter += 1
        else:
            i_first += 1
            continue

        if counter == attempts_number:
            tbu = attempts[i] + start_time
            start_time *= 2
            if start_time > max_block:
                start_time = max_block
            counter = 0

    if tbu > cur_time:
        return tbu
    return 0


def handler(input_data):
    """
    Функция обработки ввода, вызова функции решения задачи
    :param input_data: вход
    :return: None
    """
    input_data = [line for line in input_data.split('\n') if line]
    if not input_data:
        return

    config = map(int, input_data[0].split())
    rest_time = calc_unban_time(*config, list(map(int, input_data[1:])))
    if rest_time > 0:
        print(rest_time)
        return
    print('ok')


if __name__ == '__main__':
    handler(sys.stdin.read())
